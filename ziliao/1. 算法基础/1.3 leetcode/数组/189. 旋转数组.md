### Title
给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。

```
示例 1:

输入: [1,2,3,4,5,6,7] 和 k = 3
输出: [5,6,7,1,2,3,4]
解释:
向右旋转 1 步: [7,1,2,3,4,5,6]
向右旋转 2 步: [6,7,1,2,3,4,5]
向右旋转 3 步: [5,6,7,1,2,3,4]
```
```
示例 2:

输入: [-1,-100,3,99] 和 k = 2
输出: [3,99,-1,-100]
解释: 
向右旋转 1 步: [99,-1,-100,3]
向右旋转 2 步: [3,99,-1,-100]
```
说明:

尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。
要求使用空间复杂度为 O(1) 的原地算法。

### 分析

思路：把原数组划分为两个部分来看：前 n - k 个元素 [1,2,3,4]和 后k个元素 [5,6,7]，进行分开处理

定义 reverse 逆转方法：将数组元素反转，比如 [1,2,3,4] 逆转后变成  [4,3,2,1]
对前 n - k 个元素 [1,2,3,4] 进行逆转后得到 [4,3,2,1]
对后k个元素 [5,6,7] 进行逆转后得到 [7,6,5]
将前后元素 [4,3,2,1,7,6,5] 逆转得到：[5,6,7,1,2,3,4]
注意：还要处理 k > 数组长度的情况，对 k 进行取模


### Coding
```
class Solution {
            public void rotate(int[] nums, int k) {
            k %= nums.length;
            reserve(nums,0,nums.length-1);
            reserve(nums,0,k-1);
            reserve(nums,k,nums.length-1);
        }
        void reserve(int[] nums, int start, int end){
            while (start < end){
                int temp = nums[start];
                nums[start] = nums[end];
                nums[end] = temp;
                start++;
                end--;
            }
        }
}
```